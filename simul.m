%% Pre-allocation %%
S_1 = zeros(1,nsimul);
S_2 = zeros(1,nsimul);
S_3 = zeros(1,nsimul);

%% Main %%
for i = 1:nsimul
    %% Computing the field generated by the dipoles %%
    %Adding the boom directional uncertainty%
    theta_cone = normrnd(0,delta_boom);
    est_Rib = rand_boom(theta_cone,transpose(r_IB),transpose([boom_x,boom_y,boom_z])); 
    b = norm(est_Rib);
    alpha = (b+distance_sensors)/b;
    est_Rob = alpha*est_Rib;

    B = zeros(4,3);
    %B will be a matrix such that:
        %B(1,:) = real field at sensor 1
        %B(2,:) = real field at sensor 2
        %B(3,:) = estimated field at sensor 1 using knowledge of dipoles
        %B(4,:) = estimated field at sensor 2 using knowledge of dipoles
    B = rand_dipoles(lil_n,true,0.1,false,sigma_pos,sigma_comp,r_IB,r_OB,est_Rib,est_Rob,Lx,Ly,Lz); %(number of dipoles, true==random norm, max norm of dipoles, true==known dipole)
    B = B + rand_dipoles(big_n,true,2,false,sigma_pos,sigma_comp,r_IB,r_OB,est_Rib,est_Rob,Lx,Ly,Lz);
    %the rand_dipoles function adds the field generated by random dipoles
    %(usually with unknown position and unknown magnetic dipole components)
    B = B + dip_moments(dip_positions, dip_components,sigma_pos,sigma_comp,r_IB,r_OB,est_Rib,est_Rob);
    %the dip_moments function adds the field generated by known dipoles
    
    %% Sensor inaccuracy %%
    results = zeros(2,3);
    for j=1:2
        %We define the parameters
        theta = theta0; phi = phi0; O = O_zero; Gx = G_zero;
        M = transM(theta,phi);       
        G = [Gx(1) 0 0;
             0 Gx(2) 0;
             0 0 Gx(3)];
        Bs = G*M*transpose(S + B(j,:)) + O;
        %Bs is the measured value of the background field + dipole effect
        
        %We introduce uncertainty on parameters
        Gx = normrnd(G_zero,gain_sigma);
        theta = normrnd(theta0,angle_sigma);
        phi = normrnd(phi0,angle_sigma);
        O = normrnd(O_zero,off_sigma);
        G  = [Gx(1) 0 0;
              0 Gx(2) 0;
              0 0 Gx(3)];
        M = transM(theta,phi);
        
        %Convert back to find new_B (our estimate of background field + dipole effect)
        new_B = M^(-1)*G^(-1)*(Bs-O);
        results(j,:) = transpose(new_B);
        %new_B is the estimate of the background field B%
    end
    
    %% We remove the effect of known dipoles and apply dual sensor method to remaining field %%
    B1 = results(1,:)-B(3,:);
    B2 = results(2,:)-B(4,:);
    B2 = dual_sensor(B1,B2,est_Rib,est_Rob);

    S_1(i) = B2(1); S_2(i) = B2(2); S_3(i) = B2(3);
    %S gives our final estimate of the background field after having
    %applied sensor and spacecraft inaccuracy
end

%% Functions %%
%Function that creates a rotation matrix
function matrix = transM(theta, phi)
    matrix = [cosd(theta(1)) sind(theta(1))*cosd(phi(1)) sind(theta(1))*sind(phi(1));
              cosd(theta(2)) sind(theta(2))*cosd(phi(2)) sind(theta(2))*sind(phi(2));
              cosd(theta(3)) sind(theta(3))*cosd(phi(3)) sind(theta(3))*sind(phi(3))];
end

%Function that computes the effet of a number of unknown dipoles of given amplitude
function r_dips = rand_dipoles(nsimul, bool, m_n, bool2,sigma_pos,sigma_comp,r_IB,r_OB,est_Rib,est_Rob,Lx,Ly,Lz)
    c = 1e-7; %constant used later
    B1 = [0 0 0];
    B2 = [0 0 0];
    if(bool2) %bool2 == dipoles known
        known_components = zeros(nsimul,3);
        known_positions = zeros(nsimul,3);
    end
    for i = 1:nsimul %nsimul == number of dipoles generated
        x_m = rand-Lx/2;
        y_m = rand-Ly/2;
        z_m = rand-Lz/2; %randomised position of the dipole
        phi = rand*2*pi;
        z = 2*rand - 1;
        z2 = sqrt(1-z^2);
        m_norm = 0.1;
        if(bool) %bool == random norm up to a given maximum
            m_norm = rand*m_n;
        end
        m_x = m_norm*z2*cos(phi);
        m_y = m_norm*z2*sin(phi);
        m_z = m_norm*z; %randomised direction of dipole
        m = [m_x m_y m_z];
        if(bool2)
            known_components(i,:) = m;
            known_positions(i,:) = [x_m y_m z_m];
        end
        r1_r = r_IB-[x_m y_m z_m];
        r2_r = r_OB-[x_m y_m z_m];
        B1 = c*(3*r1_r*dot(m,r1_r)/norm(r1_r)^5-m/norm(r1_r)^3) + B1; %formula for field generated by a dipole
        B2 = c*(3*r2_r*dot(m,r2_r)/norm(r2_r)^5-m/norm(r2_r)^3) + B2;
    end
    if(bool2) %if the dipoles are known (to a certain degree), call this function 
              %(see below for details)
        r_dips = known_dipoles(known_positions,known_components, B1, B2,sigma_pos,sigma_comp,est_Rib,est_Rob);
    else
        r_dips = [B1; B2;zeros(1,3);zeros(1,3)];
    end
end

%Function computes effect of dipoles given in excel file
function new_dipole = dip_moments(pos, comp, sigma_pos, sigma_comp, r_IB, r_OB,est_Rib,est_Rob)
    c = 1e-7;
    dim = size(pos);
    n = dim(1);
    B1 = [0 0 0]; B2 = [0 0 0];
    for i=1:n
        m = comp(i,:);
        x_m = pos(i,1); y_m = pos(i,2); z_m = pos(i,3);
        r1_r = r_IB -[x_m y_m z_m];
        r2_r = r_OB-[x_m y_m z_m];
        B1 = c*(3*r1_r*dot(m,r1_r)/norm(r1_r)^5-m/norm(r1_r)^3) + B1;
        B2 = c*(3*r2_r*dot(m,r2_r)/norm(r2_r)^5-m/norm(r2_r)^3) + B2;
    end
    %since these dipoles are known(to a certain degree), we call this function 
    %(see below for details)
    new_dipole = known_dipoles(pos,comp,B1,B2,sigma_pos,sigma_comp,est_Rib,est_Rob);
end

%Function computes our estimate of the effect of known dipoles
function exist_dip = known_dipoles(positions, components, B1 , B2,sigma_pos,sigma_comp,r_IB,r_OB)
    c = 1e-7;
    dim = size(positions);
    n = dim(1);
    new_B1 = B1;
    new_B2 = B2;
    new_components = zeros(n,3);
    new_positions = normrnd(positions,sigma_pos);
    %our estimated positions (and components) are off by a certain error
    %which follows a normal law ~ normrnd
    for j=1:3
        new_components(:,j) = normrnd(components(:,j),abs(sigma_comp*components(:,j)));
    end    
    for i=1:n
        m = new_components(i,:);
        r1_r = r_IB-new_positions(i,:);
        r2_r = r_OB-new_positions(i,:); 
        new_B1 = new_B1 - c*(3*r1_r*dot(m,r1_r)/norm(r1_r)^5-m/norm(r1_r)^3);
        new_B2 = new_B2 - c*(3*r2_r*dot(m,r2_r)/norm(r2_r)^5-m/norm(r2_r)^3);
    end
    exist_dip = [B1;B2;B1 - new_B1;B2 - new_B2];
    %B1 = true field at sensor 1
    %B2 = true field at sensor 2
    %B1 - new_B1 = estimated field at sensor 1
    %B2 - new_B2 = estimated field at sensor 2
end

%Function is technically useless as it just calls the next one
function dual = dual_sensor(b_1,b_2,r_IB,r_OB)
    dual = solve_sys(b_1,b_2,r_IB,r_OB);
end

%Function solves a system of equations associated to dual sensor method
function system = solve_sys(B1,B2,r_IB,r_OB)
    c = 1e-7;
 
    B = [transpose(B1);transpose(B2)];
    A = [1,0,0,c*(3*r_IB(1)^2/norm(r_IB)^5-1/norm(r_IB)^3),c*(3*r_IB(1)*r_IB(2)/norm(r_IB)^5),c*(3*r_IB(1)*r_IB(3)/norm(r_IB)^5);
         0,1,0,c*(3*r_IB(1)*r_IB(2)/norm(r_IB)^5),c*(3*r_IB(2)^2/norm(r_IB)^5-1/norm(r_IB)^3),c*(3*r_IB(2)*r_IB(3)/norm(r_IB)^5);
         0,0,1,c*(3*r_IB(1)*r_IB(3)/norm(r_IB)^5),c*(3*r_IB(2)*r_IB(3)/norm(r_IB)^5),c*(3*r_IB(3)^2/norm(r_IB)^5-1/norm(r_IB)^3);
         1,0,0,c*(3*r_OB(1)^2/norm(r_OB)^5-1/norm(r_OB)^3),c*(3*r_OB(1)*r_OB(2)/norm(r_OB)^5),c*(3*r_OB(1)*r_OB(3)/norm(r_OB)^5);
         0,1,0,c*(3*r_OB(1)*r_OB(2)/norm(r_OB)^5),c*(3*r_OB(2)^2/norm(r_OB)^5-1/norm(r_OB)^3),c*(3*r_OB(2)*r_OB(3)/norm(r_OB)^5);
         0,0,1,c*(3*r_OB(1)*r_OB(3)/norm(r_OB)^5),c*(3*r_OB(2)*r_OB(3)/norm(r_OB)^5),c*(3*r_OB(3)^2/norm(r_OB)^5-1/norm(r_OB)^3)];
    X = linsolve(A,B);
    
    system = X(1:3);
    %if you wish to know why this matrix represents the dual sensor method
    %please check our report (or contact us)
end

%This function returns an estimated IB sensor position (after applying
%uncertainty delta_boom)
function r = rand_boom(theta,r_IB,boom_pos)
norm_r = (r_IB-boom_pos)/norm(r_IB-boom_pos);
z = rand*(1-cosd(theta))+cosd(theta);
phi = rand*2*pi;
x = sqrt(1-z^2)*cos(phi);
y = sqrt(1-z^2)*sin(phi);

u = cross([0;0;1],norm_r);
rot = acos(dot(norm_r, [0;0;1]));

crossMatrix = @(x,y,z) [0 -z y; z 0 -x; -y x 0];
R = cos(rot) * eye(3) + sin(rot) * crossMatrix(u(1), u(2), u(3)) + (1-cos(rot))*(u * u');
% Rotate [x; y; z] from north pole to `coneDir`.
r = R * [x; y; z]*norm(r_IB-boom_pos);
r = transpose(r + boom_pos);
end

%daniel.montagna@epfl.ch
%nicholas.delmotte@epfl.ch